
My responsibility for this project was to lead the coding side of things. We
split up the main algorithms we would need to write so that each of us would be
writing them in two languages. The two I chose were Java and Python. I have
written a lot of small Python programs, and a few medium-scale ones. Java was a
major refresher, as it has been a while. I thoroughly enjoy any chance I get to
do just that. 

Writing the algorithms themselves took very little time, especially in Python. 
The language is so straight-forward that if you know what you want to do you 
can have something working in very little time. That is its strong point. Later 
in this paper, I'll discuss one of its weak points. I also used Python to 
generate our lists. 
% Russell Writeup

We decided that it would be good to have a consistent set of lists that are 
randomly generated to use across all of the sorting algorithms and all of the 
languages. There were many struggles when we were developing this list generator.
It took several tries to figure out how to build up the right amount of data in 
memory before writing it to a file, because we did not want to spend extra time 
doing more File I/O than necessary. 

At first we started with a very simple program that when given an argument, would
create 1000 new files, each containing a list of the size specified in its 
argument. This worked fine for the first few sizes, so we ran the script in 
separate shells, with different inputs, to get all of our lists ready. However,
the system ran out of memory before it could finish.

Next we decided to write each list to a file, one by one, rather than storing all 
of the information in memory and attempting to write all of the files at the end. 
This worked, but it took quite a considerable amount of time.

One of the biggest struggles we faced while working with Java was determining how 
to store the lists/arrays. At first we just wanted to have an array as a private 
field. We then discovered that most of the algorithms we were working with sorted 
in place, meaning they would change the values in the array. This wouldn't work 
for a class that has four different sort algorithms going in sequence and
accessing the same array, and unfortunately we did not abstract the sorting out 
of the primary class. Rather, we used four arrays, one dedicated to each 
algorithm.

The next tricky thing was figuring out how to run the stopwatch on the 
algorithms while they sort the lists. We had just gotten done working on the
timer in C++ and easily stuck it between the loop that switched between
different sizes of lists and the loop that iterated through each list of the
same size. Well with the way the Java program was laid out, those loops were in
very different places. However, we were able to place the stopwatch calls right
next to the sort method calls, and we used public methods to retrieve the times
from the private fields they were stored in.

The final struggle while working in Java, which carried over to implementing it
in C++ as well, was the merge sort. Because the merge sort works with a set of
lists whose sizes are constantly-changing, arrays would simply not do the trick.
Rather, what we wanted to do was learn to use the Java List class. In attempting
to do so, we also discovered the magic of the ArrayList class. Basically, it
allows you to do list operations such as cons (Java calls it add), there is also
a get function that allows you to refer to a specific index. Both of these
operations came in handy. C++ has lists in its standard library, and though it
did not have the get method, it was not difficult to make the translation from
the Java code to the C++ code.

Once we verified that all of the sorts were in fact sorting, adjusted the output
that would be written to the CSV file, tested the stopwatch, and did a dry-run
on a small set of lists, it was time to ship it. The program ran for two days
before completing all of the lists. 
%ADD MORE HERE
%ONCE JAVA PROGRAM DONE RUNNING

and still had not finished. At this point we became very worried, so we tried
timing a single list of size 100,000. In java it only took about 30 seconds, but
in C++ it took 3 minutes. We decided this could be our new size limit, and not
go all the way to one million.
